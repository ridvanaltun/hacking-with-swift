## Day 2

- array -> `let foo = ["bar", "baz"]`, erismek icin `foo[0]`
- tip belirtilmis array -> `let foo: String = ["bar", "baz"]`
- bir degisken de birden fazla veri tutmak icin array'e benzeyen ama farkli calisan bir yapi var: Set -> `let foo = Set(["a", "b", "c", "a"])`, array gibi verilen degerlerin bir index numarasi yok, 1 numarali degere eris diyemiyoruz, degerlerin hepsi rasgele konumlaniyor ve ayrica ayni itemleri otomatik siliyor, mesela 2 tane a degeri var bu sebeple cagirdigimzida sadece bir tane gozukecek. Elimizde cok fazla veri varsa ve bir verinin olup olmadigina bakmak istiyorsak Sets'i kullanmak akillica olacaktir.
- tuple yapisi var, `var foo = (first: "bar", last: "baz")`, degere erismek icin `foo.0` yada `foo.first` kullanabiliriz. icindeki degerleri tipe uyarak degistirebiliriz, yani name degeri string vererek degistirilebilir. Son tupple boyutu sabit bu sebeple ne ekstra property ekleyebiliriz yada cikartabiliriz.
- dictionary adinda bir yapimiz daha var -> `var foo = ["John Doe": 5, "Jane Doe": 10]`, veri okumak icin `foo["John Doe"]` seklinde yapiliyor. Tip berlitmek su sekilde -> `var foo: [String: Int] = ["a": 1, "b": 2]`
- eger dictionary'de olmayan bir key'e bakmaya calisirsak `nil` doner, eger nil yerine default bir deger donmesini istiyorsak deger okurken su sekilde ilerleyebiliriz -> `foo["John Doe", default: "Unknown"]`
- birden fazla veriyi tek bir degiskene koydugumuz degisken yapisini `collection` olarak kisaltabiliriz. Mevcut collectionlar -> `array, tuple, dictionary, sets`
- bos collection acmak icin tip belirtmek gerekiyor bide `()` seklinde bitirmek gerekiyor, su sekilde ilerlemek lazim: array -> `var foo = [Int]()` yani icinde Integer degerler alabilecek bir array actik, dictionary -> `var foo = [String: Int]()`, array ve dictionary disinda sets icin angle bracket kullanmak gerekiyor -> `var foo = Set<String>()`, tuple icin bos collection acamayiz cunku mantigina ters. Istersek array ve dictionary icin  angle bracket kullanabiliriz bu arada.
- actigimiz bos collection'a deger atmak icin su yol izlenebilir -> dictionary -> `foo["John Doe"] = 2`, array -> `foo.append("String Value")`,  sets -> `foo.insert("bar")`
- enum yapisi var, sabit stringleri vs tutmak ve magical number'lari vs ortadan kaldirmak icin tercih edilebilir:

```swift
enum foo {
	case bar
	case baz
}

let result = foo.bar
```

- Enum icine degerler atanabiliyor, **bunun use-case'ini anlamadim**:

```swift
enum Activity {
	case bored
	case talking(topic: String)
	case singing(volume: Int)
}

let talking = Activity.talking(topic: "games")
```

- Enum icine JS de alistigim gibi raw degerler atanabiliyor:

```swift
enum Planet: Int {
	case earth
	case mars
	case venus
}
```

Bu ornekte otomatik olarak 0 dan baslayarak raw deger alirlar, mesela burada earth degeri 0 alir. Herhangi bir degeri cagirmak icin `let planet = Planet(rawValue: 0)` seklinde kullanabiliriz. Istersek asagidaki gibi manuel olarak raw deger atayabiliriz:

```swift
enum Planet: Int {
	case earth = 1
	case mars
	case venus
}
```

Bu ornekte dunyaya 1 degeri verdigimiz ve kalanlara deger atamadigimiz icin 1'den baslayarak otomatik raw degeri atanacak.

- Enum yapisinin kullanilma mantigi sabit olan degerleri string olarak depolamak yerine daha performansli bir cozum sunmak. Her duruma karsi raw deger ozelligi var bu sebeple sabit oldugunu bildigimiz tum degerler icin enum kullanabiliyoruz.
