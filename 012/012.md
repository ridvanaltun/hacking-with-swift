## Day 12

- null tanimlamak -> `var num: Int? = nil`, burada soru isareti kullanmak zorunlu, soru isareti yoksa nil olamaz. Bu yapiya Swift te `optional` adi verilmis
- fonksiyon parametre olarak nil alabiliyorsa parametre tipinin yaninda soru isareti koymak gerekiyor, `String?`, ayni sekilde nil donebiliyorsa soru isaret iile tip'in yanina koymak gerekiyor
- nil olabilecek degiskenleri kullanirken direkt kullanmak guvenli degil ornegin bir string deger nil olabilir diye belirtip kac karakter diye bakmaya calisirsak ve o esnada degisken nil ise hata aliriz, bu durumun onune gecmek icin `unwrapping optionals` adi verilen yontemlerden birine basvurmamiz gerekiyor. Birden fazla yontem var:

`if let` syntax'i:

```swift
var name: String? = nil

if let unwrapped = name {
    print("count is \(unwrapped.count)")
} else {
    print("value is nil")
}
```

`guard let ... else` syntax'i:

```swift
func greet(_ name: String?) {
    guard let unwrapped = name else {
        print("name is missing!")
        return
    }

    print("hello, \(name)")
}
```

Bunun `if let` ile arasinda ki temel fark nil olma durumunu kodun basinda belirtilmesi, bu daha temiz bir yontem. `guard` amaci eger parametre istenilen seyi karsilamiyorsa fonksiyondan direkt olarak cikarmak.

Istersek guard'i else ile kullanmayabiliriz ancak bu sefer parametre nil olmadigi durumu guard icine yazmamiz gerekir ve kod intent olacagi icin okumasi zorlasir. Else ifadesini kaldirmak yeterli bu durum icin.

- string bir ifadeyi integer'a cevirirken Swift'e bu ifadenin kesinlikle integer bir deger oldugunu optional olmadigini soylemek icin `crash operator` kullanmamiz gerekiyor. String herhangi bir deger olabilecegi icin integer'a cevirirken Swift default olarak `optional` cevrim yapar.

```swift
let str = "5"
let num = Int(str)! // Swift'e bu degisken asla nil olamaz diye soyledik
```

Degisken nil olamaz diye belirtirsek ve nil olursa uygulamamiz aninda crash edecektir. Sadece emin oldugumuz durumlarda crash operator kullanmaliyiz.

- `implicitly unwrapped optionals` adinda `optionals` alternetifi bir degisken tanimlama yontemi var. Eger tanimladigimiz degisken nil olabiliyorsa ancak deger atandiktan sonra hic nil olmuyorsa bu sekilde degisken tanimlayabiliriz. Degisken sonradan nil'e donerse uygulama crash edecektir.

`optionals` kullanirken `guard let` yada `if let` syntax'i kullanmak zorundayiz ancak bu yeni tanimlamada bunlari kullanmamiza gerek kalmiyor cunku swift'e biz zaten bu degerin nil oalrak tanimlandigii ancak icine deger atandigini ve bir daha nil degeri almayacagini belirtiyoruz, bu sebeple bu deger baslangicta nil ancak sonrasinda normal bir deger olarak ele aliniyor.

```swift
var num: Int! = nil
```

- `nil coalescing` ile eger yazdigimiz bir fonksiyon nil donebiliyorsa bu fonksiyonun ciktisini tek satirda halledebilmek icin bir syntax koymulsar:

```swift
func username(for id: Int) -> String? {
    if id == 1 {
        return "foo"
    } else {
        return nil
    }
}

username(for: 5) ?? "bar" // bar
```

Buna cok gerek var cunku unwraped etmeye calisirsak her seferinde kod gereksiz yere okumasi zor hale gelir.

- `optional chaining` diye JS de kullandigim bir ozellik var, soru isareti ile bir objenin icinde olmayan bir property veya fonksiyona erismeye calisirsak normalde crash yeriz, soru isareti kullanarak erismeye calisirsak nil doner.

- `do try catch` yapisi `if let try?` yapisina cevrilebilir. Eger fonksiyon throw yaparsa bunu `try?` ile nil e cevrirebiliriz:

```swift
if let res = try? checkPassword("pass") {
    print("success -> \(res)")
} else {
    print("failure")
}
```

- eger donen deger kesinlikle nil olmayacagi belliyse `try!` yapisini kullanip yazilan kodu azaltabiliriz:

```swift
try! checkPassword("pass")
```

- Kisacasi nil olabilen degiskenleri kesinlikle unwrap'lamak gerekiyor.
- `failable initializers`, struct init ederken yazdigimiz struct aldigi degerleri begenmeyebilir ve fail edebilir, bu durumda nil dondurmesi gerekir. Nil dondurebildigi icin bunu init fonksiyonuna tanimlamamiz gerekiyor:

```swift
struct Person {
    var name: String

    init?(name: String) {
        if name.count < 2 {
            return nil
        }

        self.name = name
    }
}
```

- `type casting` ile bir degiskenin hangi tipte oldugunu kontrol edebilme imkani taniyor. Aslinda verdigimiz degiskenin tipini cevirmeye calisiyor eger ceviremezse nil donuyor. `as?` ile yapiyoruz bu isi ve nil isin icine girdigi icin unwrap etmek gerekli bu sebeple `if let` kullaniyoruz.

```swift
let animals = [Dog(), Cat(), Dog(), Duck()]

for animal in animals {
    if let dog = animal as? Dog {
        dog.bark()
    }
}
```